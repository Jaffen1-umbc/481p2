Client workings:
	1. parse cmd line args
	2. play the game
	3. close
	
	2. play the game
		a. add a fake server response that was requesting the first args to the queue 
		b. get the next item in the queue
		c. if the item from the queue was sent by the client, and we know the server has last requested a int response
			i. then send the data to the server
		d. else if the data was a server response
			i. print the message from the server
			ii. check the action required by client:
				1. terminate connection?
					- close game
				2. expecting first args?
					-send the start_mark (SERVER_MARK or CLIENT_MARK) for who goes first to the server
	
Server workings:
	1. listen to port for messages
	2. create a new thread to deal with message
		a. if a game exists between that connection already
			i. call to pass_client_message with the message recived
		b. else if a game does not exist yet, create a new game
			i. pass this new game the address, unique id, and the command line args value for who goes first
			ii. call to pass_client_message with Null(None) message

	pass_client_message(self, client_message)
		a. checks self game state for if the game has already ended
			i. if game has ended then send a terminate message to client, remove self from ACTIVE_GAMES, return from pass_client_message
		b. checks for if it is currently the clients turn
			i. if input is None or 9 then send a terminate message to client, remove self from ACTIVE_GAMES, return from pass_client_message
			ii. else check the validity of the input (single digits only)
				1. try to make the client move
					a. if successful, change the turns
					b. if failure, print some error message
		c. checks for if it is the servers turn (will execute after [pass_client_message.b] completed)
			i. try to make the server move
				1. if successful, change the turns
				2. if failure, print some error message
		d. checks self game state for if the game has ended
			i. if game has ended then send a terminate message to client, remove self from ACTIVE_GAMES, return from pass_client_message
		e. sends an updated game board to the client with EXPECTING INT RESPONSE
#################################################################
#	Tic-Tac-Toe Protocol Explination                            #
#                                                               #
#                                                               #
#   Noah Jaffe                                                  #
#   UDP Socket Programming                                      #
#   CMSC 481                                                    #
#   11/05/2018                                                  #
#################################################################


The tic tac toe protocol: 
TTT_PRTCL: 
	SENDING FROM SERVER TO CLIENT:
	Encode message string							encoded = message.encode()
	Pack message response length '!I'
	SEND PACKED: MESSAGE RESPONSE LENGTH			SOCK.sendto(struct.pack('!I', sys.getsizeof(encoded)), addr) #send size of 37
	SEND: MESSAGE									SOCK.sendto(encoded, addr) #send variable size
	pack expecting response val '!I'
	SEND PACKED: EXPECTING RESPONSE VAL				SOCK.sendto(struct.pack('!I', expecting_response_val), addr) #send size of 37
	
	
	PROTOCOL TO RECIEVE A MESSAGE RECIEVING FROM SERVER TO CLIENT: 
		RECV PACKED: MESSAGE RESPONSE LENGTH
		unpack '!I' and .recv that many bytes
		RECV: MESSAGE
		RECV PACKED: EXPECTING RESPONSE VAL
		unpack '!i' and add to ret_list


	SENDING FROM CLIENT TO SERVER:
		pack single digit val '!I'			packed_int_val = struct.pack('!I', <unsigned int>)
		SEND PACKED: SINGLE DIGIT VAL			connection.sendall(packed_int_val)

	RECIEVING FROM CLIENT TO SERVER:
		RECV PACKED: SINGLE DIGIT VAL			packed_int_val = connection.recv(4)
		unpack '!I'					int_val = struct.unpack('!I', packed_int_val)

CONSTANTS AND GLOBALS:
---------------------------------------------------------------------------------------------------
TTT_SERVER_PORT = 13037
---------------------------------------------------------------------------------------------------
TTT_PRTCL_TERMINATE = 0
---------------------------------------------------------------------------------------------------
TTT_PRTCL_EXPECTING_NO_RESPONSE = 1
---------------------------------------------------------------------------------------------------
TTT_PRTCL_EXPECTING_INT_RESPONSE = 2
---------------------------------------------------------------------------------------------------
TTT_PRTCL_EXPECTING_FIRST_ARGS_RESPONSE = 3
---------------------------------------------------------------------------------------------------
TTT_PRTCL_PACKED_UNSIGNED_INT_SIZE = 4 #4 is the size of a packed '!I' value
---------------------------------------------------------------------------------------------------
TTT_PRTCL_REQUEST_FIRST_ARGS = 
Please send an unsigned int representing if the client wishes to make the first move.
	0 -- sever should go first
	1 -- client should go first
---------------------------------------------------------------------------------------------------
TTT_PRTCL_GOT_FIRST_ARGS_ERR =
Failed to receive proper game initiation arguments. Terminating connection.
Next time Please send an unsigned int representing if the client wishes to make the first move.
	0 -- sever should go first
	1 -- client should go first
---------------------------------------------------------------------------------------------------
TTT_PRTCL_INSTRUCTIONS =
Welcome to Tic Tac Toe!
Enter [0-8] for the position of your move, or 9 to quit:
0|1|2
-----
3|4|5
-----
6|7|8
---------------------------------------------------------------------------------------------------
TTT_PRTCL_INVALID_CLIENT_INPUT = 
Invalid input, try again.
---------------------------------------------------------------------------------------------------
TTT_PRTCL_REQUEST_CLIENT_TURN = 
 | | 
-----
 | | 
-----
 | | 
Enter [0-8] for the position of your move, or 9 to quit:
---------------------------------------------------------------------------------------------------
TTT_PRTCL_CLIENT_ERR =
Sorry, that was invalid input. Please try again.
---------------------------------------------------------------------------------------------------

TO CREATE YOUR OWN CLIENT:
I have provided a ttt.py that defines the four functions described above and has all of the constants defined inside.
To use it you just need to import it.

example useage:
	import ttt
	...
	ttt.SEND_FROM_CLIENT_TO_SERVER(my_socket_connection, my_data)





